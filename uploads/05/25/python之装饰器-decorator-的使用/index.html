<!DOCTYPE html><html class="theme-next pisces use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2"><link rel="stylesheet" href="/css/main.css?v=7.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.1"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.1"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.1"><link rel="mask-icon" href="/images/logo.svg?v=7.1.1" color="#222"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"7.1.1",sidebar:{position:"left",display:"post",offset:12,onmobile:!1,dimmer:!1},back2top:!0,back2top_sidebar:!0,fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="description" content="装饰器定义：本质是函数，装饰其他函数(为其他函数添加附加功能) 原则：  不能修改被装饰的函数的源代码 不能修改被装饰的函数的调用方式  实现装饰器知识储备 函数即“变量”  高阶函数  把一个函数名当作实参传给另一个函数  返回值中包含函数名    嵌套函数   即高阶函数+嵌套函数=&amp;gt;装饰器 示例代码12345678910111213141516import timedef timmer"><meta name="keywords" content="python,装饰器"><meta property="og:type" content="article"><meta property="og:title" content="python之装饰器、生成器、迭代器"><meta property="og:url" content="http://blog.nativefans.top/2019/05/25/python之装饰器-decorator-的使用/index.html"><meta property="og:site_name" content="めあくあ厨的博客"><meta property="og:description" content="装饰器定义：本质是函数，装饰其他函数(为其他函数添加附加功能) 原则：  不能修改被装饰的函数的源代码 不能修改被装饰的函数的调用方式  实现装饰器知识储备 函数即“变量”  高阶函数  把一个函数名当作实参传给另一个函数  返回值中包含函数名    嵌套函数   即高阶函数+嵌套函数=&amp;gt;装饰器 示例代码12345678910111213141516import timedef timmer"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="http://blog.nativefans.top/2019/05/25/python之装饰器-decorator-的使用/2.PNG"><meta property="og:image" content="http://blog.nativefans.top/2019/05/25/python之装饰器-decorator-的使用/1.png"><meta property="og:updated_time" content="2019-05-27T16:08:55.917Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="python之装饰器、生成器、迭代器"><meta name="twitter:description" content="装饰器定义：本质是函数，装饰其他函数(为其他函数添加附加功能) 原则：  不能修改被装饰的函数的源代码 不能修改被装饰的函数的调用方式  实现装饰器知识储备 函数即“变量”  高阶函数  把一个函数名当作实参传给另一个函数  返回值中包含函数名    嵌套函数   即高阶函数+嵌套函数=&amp;gt;装饰器 示例代码12345678910111213141516import timedef timmer"><meta name="twitter:image" content="http://blog.nativefans.top/2019/05/25/python之装饰器-decorator-的使用/2.PNG"><link rel="canonical" href="http://blog.nativefans.top/2019/05/25/python之装饰器-decorator-的使用/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>python之装饰器、生成器、迭代器 | めあくあ厨的博客</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">めあくあ厨的博客</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"><dd是怎样炼成的></dd是怎样炼成的></p></div><div class="site-nav-toggle"> <button aria-label="切换导航栏"><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-首页"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-关于"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-标签"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-分类"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://blog.nativefans.top/2019/05/25/python之装饰器-decorator-的使用/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Y.Y.P"><meta itemprop="description" content><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="めあくあ厨的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">python之装饰器、生成器、迭代器</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-05-25 17:05:01" itemprop="dateCreated datePublished" datetime="2019-05-25T17:05:01+08:00">2019-05-25</time> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-05-28 00:08:55" itemprop="dateModified" datetime="2019-05-28T00:08:55+08:00">2019-05-28</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><p><strong>定义</strong>：本质是函数，装饰其他函数(为其他函数添加附加功能)</p><p><strong>原则</strong>：</p><ol><li>不能修改被装饰的函数的源代码</li><li>不能修改被装饰的函数的调用方式</li></ol><h2 id="实现装饰器知识储备"><a href="#实现装饰器知识储备" class="headerlink" title="实现装饰器知识储备"></a>实现装饰器知识储备</h2><ul><li><p>函数即“变量”</p></li><li><p>高阶函数</p><ol><li><p>把一个函数名当作实参传给另一个函数</p></li><li><p>返回值中包含函数名</p></li></ol></li><li><p>嵌套函数</p></li></ul><p>即<strong>高阶函数+嵌套函数=&gt;装饰器</strong></p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timmer</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">warpper</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">        start_time=time.time()</span><br><span class="line">        func()</span><br><span class="line">        stop_time=time.time()</span><br><span class="line">        print(<span class="string">'the func time is %s'</span> % (stop_time-start_time))</span><br><span class="line">    <span class="keyword">return</span> warpper</span><br><span class="line"></span><br><span class="line"><span class="meta">@timmer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">'in the test1'</span>)</span><br><span class="line"></span><br><span class="line">test1()</span><br></pre></td></tr></table></figure><p>相当于:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test1 = timmer(test1)</span><br><span class="line">test1()</span><br></pre></td></tr></table></figure><h2 id="装饰器的高阶应用"><a href="#装饰器的高阶应用" class="headerlink" title="装饰器的高阶应用"></a>装饰器的高阶应用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">user,passwd = <span class="string">'sd'</span>,<span class="string">'sd'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auth</span><span class="params">(auth_type)</span>:</span></span><br><span class="line">    <span class="comment">#利用传参来区分口令验证方式的使用</span></span><br><span class="line">    print(<span class="string">'auth_type:'</span>,auth_type)<span class="comment">#local和ldap都已传入</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">out_wrapper</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="comment">#增加一层函数来传入实参函数并返回函数结果</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">            print(<span class="string">'wrapper out args:'</span>,*args,**kwargs)</span><br><span class="line">            <span class="comment">#传入func的参数，这里home()和bbs()都没有参数</span></span><br><span class="line">            <span class="keyword">if</span> auth_type == <span class="string">'local'</span>:</span><br><span class="line">                username = input(<span class="string">'username:'</span>).strip()</span><br><span class="line">                password = input(<span class="string">'password:'</span>).strip()</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> user == username <span class="keyword">and</span> passwd == password:</span><br><span class="line">                    print(<span class="string">'user has passed authentication '</span>)</span><br><span class="line">                    func(*args,**kwargs)</span><br><span class="line">                    <span class="comment">#运行func函数</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    exit(<span class="string">'invalid username or password'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> auth_type == <span class="string">'ldap'</span>:</span><br><span class="line">                print(<span class="string">'不支持ldap'</span>)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> out_wrapper</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'welcome to index page'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@auth(auth_type='local')#在装饰器加上参数即可</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'welcome to home page'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@auth(auth_type='ldap')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bbs</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'welcome to bbs page'</span>)</span><br><span class="line"></span><br><span class="line">index()</span><br><span class="line">home1()</span><br><span class="line">bbs()</span><br></pre></td></tr></table></figure><hr><h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><h2 id="什么是列表生成式"><a href="#什么是列表生成式" class="headerlink" title="什么是列表生成式"></a>什么是列表生成式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#列表生成式</span></span><br><span class="line">a = [i*<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"><span class="comment">#[func(i) for i in range(10)]</span></span><br><span class="line"><span class="comment">#相当于</span></span><br><span class="line">b = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">     b.append(i*<span class="number">2</span>)</span><br><span class="line">print(a,b)</span><br></pre></td></tr></table></figure><p>a和b的结果都是[0,2,4,6,8,10,12,14,16,18]。</p><h2 id="什么是生成器"><a href="#什么是生成器" class="headerlink" title="什么是生成器"></a>什么是生成器</h2><p>生成器,给出一个指定的地址，当调用时才会生成相应的数据;<br>而列表生成式是直接创建一整个列表，不管需不需要使用到。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [i*<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100000000</span>)]<span class="comment">#列表</span></span><br><span class="line">b = (i*<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100000000</span>))<span class="comment">#生成器</span></span><br></pre></td></tr></table></figure><p>当调用<code>print(b[1000])</code>是会发生错误，因为必须循环到1000才会有b[1000]。</p><h3 id="调用生成器的唯一方法"><a href="#调用生成器的唯一方法" class="headerlink" title="调用生成器的唯一方法"></a>调用生成器的唯一方法</h3><p><code>__next__()</code>是调用生成器的唯一方法（在python2.7中是<code>next()</code>），不过基本不会调用该方法，因为一般会使用循环迭代的方式获取（循环本质是一次次的调用<code>__next__()</code>）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print(b.__next__())</span><br><span class="line"><span class="comment">#唯一方法__next__().python2.7中是next();不过基本不会调用该方法，一般使用循环迭代</span></span><br><span class="line">print(b.__next__())</span><br><span class="line">print(b.__next__())</span><br><span class="line"><span class="comment">#循环迭代</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> b:</span><br><span class="line">     print(i)</span><br></pre></td></tr></table></figure><p>执行以上代码后获得的是0,2,4…，<strong>注意<strong>next</strong>()之后不能回到上一个元素，之前的元素不保留，只停留在当前位置。</strong></p><h3 id="斐波拉契数列和yield的使用"><a href="#斐波拉契数列和yield的使用" class="headerlink" title="斐波拉契数列和yield的使用"></a>斐波拉契数列和yield的使用</h3><p><strong>斐波拉契数列，除第一个和第二个数外，任意一个数都可以由前两个数相加得到。比如:1,1,2,3,5,8,13,21,34</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(max)</span>:</span></span><br><span class="line">    n,a,b = <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; max:</span><br><span class="line">        print(b)</span><br><span class="line">        a,b = b,a+b</span><br><span class="line">        <span class="comment"># 相当于</span></span><br><span class="line">        <span class="comment"># t=(b,a+b) ,t是元组</span></span><br><span class="line">        <span class="comment"># a=t[0]</span></span><br><span class="line">        <span class="comment"># b=t[1]</span></span><br><span class="line">        n=n+<span class="number">1</span></span><br><span class="line">f = fib(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>执行以上代码可以得到一个斐波拉契数列（列表），当<code>print(b)</code>替换成<code>yield b</code>后，该列表就变成一个生成器了。</p><h3 id="生成器的应用——协程"><a href="#生成器的应用——协程" class="headerlink" title="生成器的应用——协程"></a>生成器的应用——协程</h3><p>现在我们来使用生成器来实现单线程下的并行效果，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'%s 准备吃包子'</span> % name)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        baozi = <span class="keyword">yield</span></span><br><span class="line">        print(<span class="string">'包子[%s]来了,被[%s]吃了'</span> % (baozi,name))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">    c = consumer(<span class="string">'a'</span>)</span><br><span class="line">    c2 = consumer(<span class="string">'b'</span>)</span><br><span class="line">    <span class="comment">#生成一个生成器,本身不print第一句话</span></span><br><span class="line">    c.__next__()</span><br><span class="line">    c2.__next__()</span><br><span class="line">    <span class="comment">#使生成器从头往下走，print第一句话</span></span><br><span class="line">    print(<span class="string">'开始做包子！'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">' %s 做了1个包子,分两半'</span> % name)</span><br><span class="line">        c.send(i)<span class="comment"># send()唤醒生成器并可以给yield传值</span></span><br><span class="line">        c2.send(i)</span><br><span class="line"></span><br><span class="line">producer(<span class="string">'Li'</span>)</span><br></pre></td></tr></table></figure><p>输出结果：</p> <img src="/2019/05/25/python之装饰器-decorator-的使用/2.PNG" title="输出结果"><hr><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h2 id="什么是迭代对象"><a href="#什么是迭代对象" class="headerlink" title="什么是迭代对象"></a>什么是迭代对象</h2><blockquote><p>我们已经知道，可以直接作用于for循环的数据类型有以下几种:<br>一类是集合数据类型，如list,tuple,dict,set,str等;<br>一类是generator，包括生成器和带yield的generator function。<br>这些可以直接作用于for循环的对象统称为可迭代(可循环)对象：Iterable。<br>可以使用isinstance()判断一个对象是否为Iterable对象。</p></blockquote><ul><li>isinstance()的使用<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line">a= isinstance([],Iterable)</span><br><span class="line">b= isinstance(&#123;&#125;,Iterable)</span><br><span class="line">c= isinstance(<span class="number">100</span>,Iterable)</span><br><span class="line">d= isinstance(<span class="string">'sad'</span>,Iterable)</span><br><span class="line">e= isinstance((x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)),Iterable)</span><br><span class="line"></span><br><span class="line">print(a,b,c,d,e)</span><br></pre></td></tr></table></figure></li></ul><p>输出结果:</p><blockquote><p>True True False True True</p></blockquote><h2 id="什么是迭代器"><a href="#什么是迭代器" class="headerlink" title="什么是迭代器"></a>什么是迭代器</h2><blockquote><p>可以被next()函数调用并不断返回下一个值的对象称为迭代器:Inerator。生成器肯定是迭代器。</p></blockquote><ul><li>isinstance()的使用<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line">a= isinstance([],Iterator)</span><br><span class="line">b= isinstance(&#123;&#125;,Iterator)</span><br><span class="line">c= isinstance(<span class="number">100</span>,Iterator)</span><br><span class="line">d= isinstance(<span class="string">'sad'</span>,Iterator)</span><br><span class="line">e= isinstance((x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)),Iterator)</span><br><span class="line"></span><br><span class="line">print(a,b,c,d,e)</span><br><span class="line"></span><br><span class="line"><span class="comment"># list,tuple,dict,set,str虽然是Iterable对象，但不是Inerator，</span></span><br><span class="line"><span class="comment"># 要变成迭代器可以使用iter()函数</span></span><br><span class="line">a= isinstance(iter([]),Iterator)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure></li></ul><p>输出结果:</p><blockquote><p>False False False False True<br>True</p></blockquote><h2 id="为什么list-tuple-dict-set-str不是Inerator（迭代器）"><a href="#为什么list-tuple-dict-set-str不是Inerator（迭代器）" class="headerlink" title="为什么list,tuple,dict,set,str不是Inerator（迭代器）"></a>为什么list,tuple,dict,set,str不是Inerator（迭代器）</h2><p>答:</p><blockquote><p>因为python的迭代器对象表示是一个数据流，<br>可被next()函数调用并不断返回下一个数据,<br>直到没有数据时抛出StopIteration错误。<br>该数据流是一个有序序列，但我们不知道序列的长度，<br>只能不断通过next()函数实现按需计算下一个数据，<br>所以Iterator的计算是惰性的，只有在需要返回下一个数据时才会计算。<br>Iterator甚至可以表示一个无限大的数据流，例如全体自然数，而使用list是永远不可能存储全体自然数的。</p></blockquote><p>** 在3.xpython中range(x)是一个迭代器(for循环其实就是通过next()来获取下一个数据)，2.7中则是直接生成一个固定长度列表 **</p><hr><h1 id="Json的序列化和反序列化"><a href="#Json的序列化和反序列化" class="headerlink" title="Json的序列化和反序列化"></a>Json的序列化和反序列化</h1><p><strong>介绍：json基本所有语言都适用，作用主要用于不同语言之间进行数据交互(以前是xml),而json序列化就是把json字典变成字符串形式。</strong><br>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'yyp'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#方法1</span></span><br><span class="line"><span class="comment">#json序列化</span></span><br><span class="line">f = open(<span class="string">'text.text'</span>, <span class="string">'w'</span>)</span><br><span class="line">f.write(str(info))</span><br><span class="line">f.close()</span><br><span class="line"><span class="comment">#json反序列化</span></span><br><span class="line">f = open(<span class="string">'text.text'</span>,<span class="string">'r'</span>)</span><br><span class="line">data = eval(f.read())<span class="comment">#eval:执行括号中字符串语句并输出</span></span><br><span class="line">f.close()</span><br><span class="line">print(data[<span class="string">'age'</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#方法2</span></span><br><span class="line"><span class="keyword">import</span> json<span class="comment">#处理简单的json序列化，无法处理函数</span></span><br><span class="line"><span class="keyword">import</span> pickle<span class="comment">#处理复杂的,与json用法完全一样,且只能在python环境下使用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send</span> <span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'hello'</span>,name)</span><br><span class="line"></span><br><span class="line">info = &#123;</span><br><span class="line">    <span class="string">'name'</span>:<span class="string">'yyp'</span>,</span><br><span class="line">    <span class="string">'age'</span>:<span class="number">22</span>,</span><br><span class="line">    <span class="string">'func'</span>:send<span class="comment">#传入内存地址(伴随程序结束而消失),因为是bytes，所以open要用二进制模式b</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#json序列化</span></span><br><span class="line">f = open(<span class="string">'text1.text'</span>,<span class="string">'wb'</span>)</span><br><span class="line"><span class="comment">#f.write(json.dumps(info))</span></span><br><span class="line">f.write(pickle.dumps(info))</span><br><span class="line"><span class="comment">#也可以用pickle.dump(info,f)</span></span><br><span class="line">f.close()</span><br><span class="line"><span class="comment">#反序列化</span></span><br><span class="line">f = open(<span class="string">'text1.text'</span>,<span class="string">'rb'</span>)</span><br><span class="line"><span class="comment">#data = json.loads(f.read())</span></span><br><span class="line">data = pickle.loads(f.read())</span><br><span class="line"><span class="comment">#也可以用data = pickle.load(f)</span></span><br><span class="line">print(data[<span class="string">'age'</span>])</span><br><span class="line"><span class="comment">#反序列化时函数名一样的情况下内容可以不相同,也就是说虽然传入的是内存地址，但是其实序列化的是整个函数本身,因为两个程序的内存不可能互相访问的</span></span><br><span class="line">print(data[<span class="string">'func'</span>](<span class="string">'yyp'</span>))</span><br></pre></td></tr></table></figure><p>注：在使用json和pickle方法时，单个文件只dump一次load一次，如果需要存多个状态就存放多个文件，不然会出错。</p><hr> <img src="/2019/05/25/python之装饰器-decorator-的使用/1.png"></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/python-装饰器/" rel="tag"># python,装饰器</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2019/05/22/国外博客转载-flare梅芙梅拉/" rel="next" title="国外博客转载-flare梅芙梅拉"><i class="fa fa-chevron-left"></i> 国外博客转载-flare梅芙梅拉</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/2019/06/05/python之socket实现/" rel="prev" title="python之socket实现">python之socket实现<i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap"> 站点概览</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="Y.Y.P"><p class="site-author-name" itemprop="name">Y.Y.P</p><div class="site-description motion-element" itemprop="description"></div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives"><span class="site-state-item-count">9</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">9</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="https://github.com" title="https://github.com" rel="noopener" target="_blank">Github</a></li></ul></div></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#装饰器"><span class="nav-number">1.</span> <span class="nav-text">装饰器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#实现装饰器知识储备"><span class="nav-number">1.1.</span> <span class="nav-text">实现装饰器知识储备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#示例代码"><span class="nav-number">1.2.</span> <span class="nav-text">示例代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#装饰器的高阶应用"><span class="nav-number">1.3.</span> <span class="nav-text">装饰器的高阶应用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#生成器"><span class="nav-number">2.</span> <span class="nav-text">生成器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是列表生成式"><span class="nav-number">2.1.</span> <span class="nav-text">什么是列表生成式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是生成器"><span class="nav-number">2.2.</span> <span class="nav-text">什么是生成器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#调用生成器的唯一方法"><span class="nav-number">2.2.1.</span> <span class="nav-text">调用生成器的唯一方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#斐波拉契数列和yield的使用"><span class="nav-number">2.2.2.</span> <span class="nav-text">斐波拉契数列和yield的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生成器的应用——协程"><span class="nav-number">2.2.3.</span> <span class="nav-text">生成器的应用——协程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#迭代器"><span class="nav-number">3.</span> <span class="nav-text">迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是迭代对象"><span class="nav-number">3.1.</span> <span class="nav-text">什么是迭代对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是迭代器"><span class="nav-number">3.2.</span> <span class="nav-text">什么是迭代器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么list-tuple-dict-set-str不是Inerator（迭代器）"><span class="nav-number">3.3.</span> <span class="nav-text">为什么list,tuple,dict,set,str不是Inerator（迭代器）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Json的序列化和反序列化"><span class="nav-number">4.</span> <span class="nav-text">Json的序列化和反序列化</span></a></li></ol></div></div></div><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span><span class="with-love" id="animate"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">Y.Y.P</span></div><div class="powered-by">感谢 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 爸爸的赞助 v3.8.0</div> <span class="post-meta-divider">|</span><div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.1.1</div></div></footer></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script src="/lib/jquery/index.js?v=2.1.3"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/js/utils.js?v=7.1.1"></script><script src="/js/motion.js?v=7.1.1"></script><script src="/js/affix.js?v=7.1.1"></script><script src="/js/schemes/pisces.js?v=7.1.1"></script><script src="/js/scrollspy.js?v=7.1.1"></script><script src="/js/post-details.js?v=7.1.1"></script><script src="/js/next-boot.js?v=7.1.1"></script></body></html>